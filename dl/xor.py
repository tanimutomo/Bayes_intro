import torchimport torch.nn.functional as Fclass XOR(torch.nn.Module):    def __init__(self, D_in, H, D_out):        super(XOR, self).__init__()        self.W = torch.nn.Linear(D_in, H)        self.w = torch.nn.Linear(H, D_out)    def forward(self, x):        h_relu = F.tanh(self.W(x))        y_pred = self.w(h_relu)        return y_predD_in, H, D_out = 2, 2, 1x = torch.Tensor([[0, 0], [0, 1], [1, 0], [1, 1]])y = torch.Tensor([0, 1, 1, 0]).view(-1, 1)model = XOR(D_in, H, D_out)criterion = torch.nn.MSELoss(size_average=False)optimizer = torch.optim.SGD(model.parameters(), lr = 0.01, momentum=0.9)epochs = 1000for epoch in range(epochs):    y_pred = model(x)    optimizer.zero_grad()    loss = criterion(y_pred, y)    if epoch % 100 == 0:        print(epoch, loss.item())    loss.backward()    optimizer.step()print('W-weight:', model.W.weight)print('W-bias:', model.W.bias)print('w-weight:', model.w.weight)print('w-bias:', model.w.bias)print('y:', model(x))# param_train_data = torch.linspace(P, 1-P, N).view(-1, 1)# param_train_data = torch.cat([param_train_data, param_train_data], dim=1)# train_data = torch.bernoulli(param_train_data)